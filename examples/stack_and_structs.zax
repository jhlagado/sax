module StackAndStructs

; Example showing:
; - locals and args as SP-relative stack slots
; - record field addressing (rec.field is an ea)
; - array addressing (arr[i] is an ea)
; - stack-delta tracking for push/pop and calls

type Sprite {
  x: word
  y: word
  flags: byte
}

var
  sprites: Sprite[4]

; Simple function that uses push/pop (net stack delta 0) around scratch usage.
export func sum_words(a: word, b: word): word {
  asm
    push de
    ld hl, (a)
    ld de, (b)
    add hl, de
    pop de
    ret
}

; Bump sprites[i].x by dx (dx is zero-extended in v0.1).
export func bump_sprite_x(i: byte, dx: byte): void {
  asm
    ; Convert i to an index register
    ld a, (i)
    ld c, a

    ; HL = sprites[i].x
    ; (Non-encodable ea operands are lowered by the compiler.)
    ld hl, (sprites[C].x)

    ; HL += dx
    ld a, (dx)
    ld e, a
    ld d, 0
    add hl, de

    ; sprites[i].x = HL
    ld (sprites[C].x), hl
    ret
}
